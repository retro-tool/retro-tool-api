defmodule XrtWeb.Schemas.Queries.RetroTest do
  use XrtWeb.GraphqlCase

  import Plug.Test
  import Xrt.Factory

  alias Xrt.Repo
  alias Xrt.Retros.Retro

  setup do
    %{conn: build_conn() |> init_test_session(%{})}
  end

  describe "retro" do
    @query """
      query getRetro($slug: String, $previousRetroId: Int) {
        retro(slug: $slug, previousRetroId: $previousRetroId) {
          slug
          works {
            title
            similarItems {
              title
            }
          }
          improve {
            title
            similarItems {
              id
            }
          }
          others {
            title
            similarItems {
              id
            }
          }
          actionItems { title }
          nextRetro { slug }
          previousRetro { slug }
        }
      }
    """

    test "returns an existing retro", %{conn: conn} do
      retro = insert(:retro)
      retro_item = insert(:retro_item, type: :works, retro: retro)
      insert(:retro_item, type: :works, retro: retro, parent_retro_item: retro_item)

      result =
        conn
        |> run(@query, %{slug: retro.slug})
        |> query_result()

      assert result == %{
               "data" => %{
                 "retro" => %{
                   "slug" => retro.slug,
                   "works" => [%{"similarItems" => [%{"title" => nil}], "title" => nil}],
                   "improve" => [],
                   "others" => [],
                   "actionItems" => [],
                   "nextRetro" => nil,
                   "previousRetro" => nil
                 }
               }
             }
    end

    test "it creates the retro with a autogenerated slug if none is provided", %{conn: conn} do
      %{"data" => %{"retro" => %{"slug" => slug}}} =
        conn
        |> run(@query, %{slug: nil})
        |> query_result()

      assert slug != nil
    end

    test "it creates the retro with the previous_retro set if the id is passed", %{conn: conn} do
      previous_retro = insert(:retro)

      result =
        conn
        |> run(@query, %{slug: nil, previousRetroId: previous_retro.id})
        |> query_result()

      previous_retro_slug = previous_retro.slug

      assert %{
               "data" => %{
                 "retro" => %{
                   "previousRetro" => %{
                     "slug" => ^previous_retro_slug
                   }
                 }
               }
             } = result
    end

    test "it creates the retro if it doesn't exist", %{conn: conn} do
      slug = "custom-slug"

      result =
        conn
        |> run(@query, %{slug: slug})
        |> query_result()

      assert result == %{
               "data" => %{
                 "retro" => %{
                   "slug" => slug,
                   "works" => [],
                   "improve" => [],
                   "others" => [],
                   "actionItems" => [],
                   "nextRetro" => nil,
                   "previousRetro" => nil
                 }
               }
             }

      assert %Retro{slug: ^slug} = Repo.get_by(Retro, slug: slug)
    end

    test "it returns the next retro when there is one", %{conn: conn} do
      retro = insert(:retro)
      %{slug: next_retro_slug} = insert(:retro, previous_retro: retro)

      result =
        conn
        |> run(@query, %{slug: retro.slug})
        |> query_result()

      assert %{
               "data" => %{
                 "retro" => %{
                   "nextRetro" => %{
                     "slug" => ^next_retro_slug
                   }
                 }
               }
             } = result
    end
  end
end
